#!/usr/bin/env perl

# Pragmas.
use strict;
use warnings;

# Modules.
use PYX::Parser;

# Tags, that are simple.
our @TAGS = ('meta', 'link', 'br', 'hr', 'img', 'input', 'option');

# Debug.
our $DEBUG = 0;

# Stack.
our @stack;

# Arguments.
if ($#ARGV < 0) {
	print "Usage: $0 [filename] [-]\n";
	print "\tfilename\tprocess on filename\n";
	print "\t-\t\tprocess on stdin\n";
	exit 1;
}

# PYX::Parser object.
my $pyx_parser = PYX::Parser->new(
	'start_tag' => \&_start_tag,
	'end_tag' => \&_end_tag,
	'data' => \&_data,
	'output_rewrite' => 1,
);

# Parse from stdin.
if ($ARGV[0] eq '-') {
	$pyx_parser->parse_handler(\*STDIN);

# Parse file.
} else {
	$pyx_parser->parse_file($ARGV[0]);
}

# Process start tag.
sub _start_tag {
	my $obj = shift;
	my $tag = shift;
	_single();
	if ($DEBUG) {
		print 'push: ';	
	}
	push @stack, $tag;
	if ($DEBUG) {
		print "$tag\n";
	}
	print $obj->{'line'}, "\n";
}

# Process end tag.
sub _end_tag {
	my $obj = shift;
	_single();
	_pop_stack();
	print $obj->{'line'}, "\n";
}

# Process data.
sub _data {
	my $obj = shift;
	_single();
	print $obj->{'line'}, "\n";
}

# Process end of single.
sub _single {
	my $tag = $stack[-1];
	if ($tag && grep(m/^$tag$/ms, @TAGS)) {
		print ')'.$tag."\n";
		_pop_stack();
	}
}

# Pop stack helper.
sub _pop_stack {
	if ($DEBUG) {
		print 'pop: ';
	}
	my $x = pop @stack;
	if ($DEBUG) {
		print "$x\n";
	}
	return;
}
